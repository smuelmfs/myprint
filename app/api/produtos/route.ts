import { NextResponse } from "next/server"
import { prisma } from "@/lib/prisma"

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// GET ‚Üí Lista todos os produtos ativos
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
export async function GET() {
  try {
    const produtos = await prisma.produto.findMany({
      where: { status: "ATIVO" },
      include: {
        categoria: true,
        unidade: true,
        extras: {
          include: { extra: true },
        },
      },
      orderBy: { id: "asc" },
    })

    return NextResponse.json({ success: true, data: produtos })
  } catch (error) {
    console.error("Erro ao listar produtos:", error)
    return NextResponse.json({ success: false, message: "Erro ao carregar produtos" }, { status: 500 })
  }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// POST ‚Üí Cria um novo produto
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
export async function POST(request: Request) {
  try {
    console.log("üöÄ Iniciando POST /api/produtos")
    
    const data = await request.json()
    console.log("üì• Dados recebidos:", JSON.stringify(data, null, 2))

    // Valida√ß√£o dos campos obrigat√≥rios
    console.log("Iniciando valida√ß√µes...")
    
    if (!data.nome || data.nome.trim() === "") {
      console.log("‚ùå Valida√ß√£o falhou: Nome √© obrigat√≥rio")
      const errorResponse = {
        success: false,
        message: "Nome √© obrigat√≥rio",
        error: "Campo obrigat√≥rio"
      }
      console.log("üì§ Enviando resposta de erro:", JSON.stringify(errorResponse, null, 2))
      return NextResponse.json(errorResponse, { status: 400 })
    }
    console.log("‚úÖ Nome v√°lido")

    if (!data.referencia || data.referencia.trim() === "") {
      console.log("‚ùå Valida√ß√£o falhou: Refer√™ncia √© obrigat√≥ria")
      const errorResponse = {
        success: false,
        message: "Refer√™ncia √© obrigat√≥ria",
        error: "Campo obrigat√≥rio"
      }
      console.log("üì§ Enviando resposta de erro:", JSON.stringify(errorResponse, null, 2))
      return NextResponse.json(errorResponse, { status: 400 })
    }
    console.log("‚úÖ Refer√™ncia v√°lida")

    if (!data.categoriaId) {
      console.log("‚ùå Valida√ß√£o falhou: Categoria √© obrigat√≥ria")
      const errorResponse = {
        success: false,
        message: "Categoria √© obrigat√≥ria",
        error: "Campo obrigat√≥rio"
      }
      console.log("üì§ Enviando resposta de erro:", JSON.stringify(errorResponse, null, 2))
      return NextResponse.json(errorResponse, { status: 400 })
    }
    console.log("‚úÖ Categoria v√°lida")

    if (!data.unidadeId) {
      console.log("‚ùå Valida√ß√£o falhou: Unidade √© obrigat√≥ria")
      const errorResponse = {
        success: false,
        message: "Unidade √© obrigat√≥ria",
        error: "Campo obrigat√≥rio"
      }
      console.log("üì§ Enviando resposta de erro:", JSON.stringify(errorResponse, null, 2))
      return NextResponse.json(errorResponse, { status: 400 })
    }
    console.log("‚úÖ Unidade v√°lida")

    if (!data.tipoProduto || data.tipoProduto.trim() === "") {
      console.log("‚ùå Valida√ß√£o falhou: Tipo de produto √© obrigat√≥rio")
      const errorResponse = {
        success: false,
        message: "Tipo de produto √© obrigat√≥rio",
        error: "Campo obrigat√≥rio"
      }
      console.log("üì§ Enviando resposta de erro:", JSON.stringify(errorResponse, null, 2))
      return NextResponse.json(errorResponse, { status: 400 })
    }
    console.log("‚úÖ Tipo de produto v√°lido")

    if (!data.custoBase || isNaN(parseFloat(data.custoBase))) {
      console.log("‚ùå Valida√ß√£o falhou: Custo base √© obrigat√≥rio e deve ser um n√∫mero v√°lido")
      const errorResponse = {
        success: false,
        message: "Custo base √© obrigat√≥rio e deve ser um n√∫mero v√°lido",
        error: "Campo obrigat√≥rio"
      }
      console.log("üì§ Enviando resposta de erro:", JSON.stringify(errorResponse, null, 2))
      return NextResponse.json(errorResponse, { status: 400 })
    }
    console.log("‚úÖ Custo base v√°lido")

    if (!data.margemPadrao || isNaN(parseFloat(data.margemPadrao))) {
      console.log("‚ùå Valida√ß√£o falhou: Margem padr√£o √© obrigat√≥ria e deve ser um n√∫mero v√°lido")
      const errorResponse = {
        success: false,
        message: "Margem padr√£o √© obrigat√≥ria e deve ser um n√∫mero v√°lido",
        error: "Campo obrigat√≥rio"
      }
      console.log("üì§ Enviando resposta de erro:", JSON.stringify(errorResponse, null, 2))
      return NextResponse.json(errorResponse, { status: 400 })
    }
    console.log("‚úÖ Margem padr√£o v√°lida")

    // Verificar se a categoria existe
    console.log("Verificando se categoria existe...")
    const categoriaExiste = await prisma.categoria.findUnique({
      where: { id: data.categoriaId }
    })

    if (!categoriaExiste) {
      console.log("‚ùå Categoria n√£o encontrada")
      const errorResponse = {
        success: false,
        message: "Categoria n√£o encontrada. Por favor, selecione uma categoria v√°lida.",
        error: "Refer√™ncia inv√°lida"
      }
      console.log("üì§ Enviando resposta de erro:", JSON.stringify(errorResponse, null, 2))
      return NextResponse.json(errorResponse, { status: 400 })
    }
    console.log("‚úÖ Categoria existe")

    // Verificar se a unidade existe
    console.log("Verificando se unidade existe...")
    const unidadeExiste = await prisma.unidade.findUnique({
      where: { id: data.unidadeId }
    })

    if (!unidadeExiste) {
      console.log("‚ùå Unidade n√£o encontrada")
      const errorResponse = {
        success: false,
        message: "Unidade n√£o encontrada. Por favor, selecione uma unidade v√°lida.",
        error: "Refer√™ncia inv√°lida"
      }
      console.log("üì§ Enviando resposta de erro:", JSON.stringify(errorResponse, null, 2))
      return NextResponse.json(errorResponse, { status: 400 })
    }
    console.log("‚úÖ Unidade existe")

    // Verificar se os extras existem (se fornecidos)
    if (data.extrasIds && data.extrasIds.length > 0) {
      console.log("Verificando extras...")
      const extrasExistentes = await prisma.extra.findMany({
        where: { 
          id: { in: data.extrasIds },
          status: "ATIVO"
        }
      })

      if (extrasExistentes.length !== data.extrasIds.length) {
        console.log("‚ùå Um ou mais extras n√£o foram encontrados ou est√£o inativos")
        return NextResponse.json({ 
          success: false, 
          message: "Um ou mais extras n√£o foram encontrados ou est√£o inativos" 
        }, { status: 400 })
      }
      console.log("‚úÖ Extras v√°lidos")
    }

    // Verificar se a refer√™ncia j√° existe (apenas produtos ativos)
    console.log("Verificando se refer√™ncia j√° existe...")
    const produtoExistente = await prisma.produto.findFirst({
      where: { 
        referencia: data.referencia,
        status: "ATIVO"
      }
    })

    if (produtoExistente) {
      console.log("‚ùå J√° existe um produto ativo com esta refer√™ncia")
      const errorResponse = {
        success: false,
        message: "J√° existe um produto ativo com esta refer√™ncia. Por favor, escolha uma refer√™ncia diferente.",
        error: "Refer√™ncia duplicada"
      }
      console.log("üì§ Enviando resposta de erro de refer√™ncia:", JSON.stringify(errorResponse, null, 2))
      return NextResponse.json(errorResponse, { status: 400 })
    }
    console.log("‚úÖ Refer√™ncia √∫nica (considerando apenas produtos ativos)")

    console.log("Tentando criar produto...")
    
    const produtoData = {
      nome: data.nome,
      referencia: data.referencia,
      descricao: data.descricao || null,
      categoriaId: data.categoriaId,
      unidadeId: data.unidadeId,
      tipoProduto: data.tipoProduto,
      custoBase: parseFloat(data.custoBase),
      margemPadrao: parseFloat(data.margemPadrao),
      // Caracter√≠sticas t√©cnicas principais
      corTipo: data.corTipo && data.corTipo.trim() !== "" ? data.corTipo : null,
      formato: data.formato && data.formato.trim() !== "" ? data.formato : null,
      paginas: data.paginas ? parseInt(data.paginas) : null,
      gramagem: data.gramagem ? parseInt(data.gramagem) : null,
      tipoPapel: data.tipoPapel && data.tipoPapel.trim() !== "" ? data.tipoPapel : null,
      acabamento: data.acabamento && data.acabamento.trim() !== "" ? data.acabamento : null,
      largura: data.largura ? parseFloat(data.largura) : null,
      altura: data.altura ? parseFloat(data.altura) : null,
      material: data.material && data.material.trim() !== "" ? data.material : null,
      metodoImpressao: data.metodoImpressao && data.metodoImpressao.trim() !== "" ? data.metodoImpressao : null,
      frenteVerso: data.frenteVerso && data.frenteVerso.trim() !== "" ? data.frenteVerso : null,
      possuiFoil: data.possuiFoil ?? false,
      corteEspecial: data.corteEspecial ?? false,
      plastificacao: data.plastificacao && data.plastificacao.trim() !== "" ? data.plastificacao : null,
      dobraVinco: data.dobraVinco && data.dobraVinco.trim() !== "" ? data.dobraVinco : null,
      espessura: data.espessura ? parseFloat(data.espessura) : null,
      suporteMaterial: data.suporteMaterial && data.suporteMaterial.trim() !== "" ? data.suporteMaterial : null,
      // Campos espec√≠ficos por tipo de produto
      tipoTecido: data.tipoTecido && data.tipoTecido.trim() !== "" ? data.tipoTecido : null,
      areaImpressao: data.areaImpressao && data.areaImpressao.trim() !== "" ? data.areaImpressao : null,
      materialObjeto: data.materialObjeto && data.materialObjeto.trim() !== "" ? data.materialObjeto : null,
      dimensoes: data.dimensoes && data.dimensoes.trim() !== "" ? data.dimensoes : null,
      materialSuporte: data.materialSuporte && data.materialSuporte.trim() !== "" ? data.materialSuporte : null,
    }

    console.log("Dados do produto preparados:", JSON.stringify(produtoData, null, 2))
    console.log("Extras IDs recebidos:", data.extrasIds)

    // Criar produto primeiro (sem transa√ß√£o para debug)
    console.log("Criando produto com dados:", JSON.stringify(produtoData, null, 2))
    
    const produto = await prisma.produto.create({
      data: produtoData,
    })

    console.log("Produto criado com ID:", produto.id)

    // Adicionar relacionamentos com extras se fornecidos
    if (data.extrasIds && data.extrasIds.length > 0) {
      console.log("Criando relacionamentos com extras:", data.extrasIds)
      await prisma.produtoExtra.createMany({
        data: data.extrasIds.map((extraId: number) => ({
          produtoId: produto.id,
          extraId: extraId,
        })),
      })
    }

    // Retornar produto com relacionamentos
    const novoProduto = await prisma.produto.findUnique({
      where: { id: produto.id },
      include: {
        categoria: true,
        unidade: true,
        extras: {
          include: { extra: true },
        },
      },
    })

    console.log("Produto criado com sucesso:", novoProduto?.id)

    console.log("‚úÖ Produto criado com sucesso, retornando resposta...")
    return NextResponse.json({ success: true, data: novoProduto })
  } catch (error) {
    console.error("üí• ERRO CAPTURADO na API:", error)
    console.error("üìä Tipo do erro:", typeof error)
    console.error("üîç √â inst√¢ncia de Error?", error instanceof Error)
    
    if (error instanceof Error) {
      console.error("üìù Mensagem de erro:", error.message)
      console.error("üè∑Ô∏è Nome do erro:", error.name)
      console.error("üìö Stack trace:", error.stack)
    }
    
    // Verificar se √© erro de valida√ß√£o do Prisma
    if (error && typeof error === 'object' && 'code' in error) {
      const prismaError = error as { code: string; meta?: { target?: string[] } }
      console.error("üî¢ C√≥digo do erro Prisma:", prismaError.code)
      console.error("üìã Meta do erro:", prismaError.meta)
    }
    
    // Tratar erros espec√≠ficos do Prisma
    if (error && typeof error === 'object' && 'code' in error) {
      const prismaError = error as { code: string; meta?: { target?: string[] } }
      
      // Erro de constraint √∫nica (refer√™ncia duplicada)
      if (prismaError.code === 'P2002') {
        const target = prismaError.meta?.target
        if (target && target.includes('referencia')) {
          console.log("‚ùå Retornando erro de refer√™ncia duplicada")
          return NextResponse.json({ 
            success: false, 
            message: "J√° existe um produto ativo com esta refer√™ncia. Por favor, escolha uma refer√™ncia diferente.",
            error: "Refer√™ncia duplicada"
          }, { status: 400 })
        }
      }
      
      // Erro de foreign key
      if (prismaError.code === 'P2003') {
        console.log("‚ùå Retornando erro de foreign key")
        return NextResponse.json({ 
          success: false, 
          message: "Categoria ou unidade selecionada n√£o existe. Por favor, verifique os dados.",
          error: "Refer√™ncia inv√°lida"
        }, { status: 400 })
      }
    }
    
    console.log("‚ùå Retornando erro gen√©rico")
    
    // Garantir que sempre retornamos uma resposta JSON v√°lida
    const errorResponse = {
      success: false,
      message: "Erro ao criar produto. Tente novamente ou entre em contato com o suporte.",
      error: error instanceof Error ? error.message : "Erro desconhecido",
      timestamp: new Date().toISOString()
    }
    
    console.log("üì§ Enviando resposta de erro:", JSON.stringify(errorResponse, null, 2))
    
    return NextResponse.json(errorResponse, { status: 500 })
  }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// PUT ‚Üí Atualiza um produto existente
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
export async function PUT(request: Request) {
  try {
    const data = await request.json()
    const { id } = data

    const produtoAtualizado = await prisma.produto.update({
      where: { id: Number(id) },
      data: {
        nome: data.nome,
        referencia: data.referencia,
        descricao: data.descricao || null,
        categoriaId: data.categoriaId,
        unidadeId: data.unidadeId,
        tipoProduto: data.tipoProduto,
        custoBase: parseFloat(data.custoBase),
        margemPadrao: parseFloat(data.margemPadrao),
        precoBase: data.precoBase ? parseFloat(data.precoBase) : null,
        corTipo: data.corTipo || null,
        formato: data.formato || null,
        paginas: data.paginas || null,
        gramagem: data.gramagem || null,
        tipoPapel: data.tipoPapel || null,
        acabamento: data.acabamento || null,
        largura: data.largura || null,
        altura: data.altura || null,
        areaM2: data.areaM2 || null,
        material: data.material || null,
        metodoImpressao: data.metodoImpressao || null,
        frenteVerso: data.frenteVerso || null,
        possuiFoil: data.possuiFoil ?? false,
        corteEspecial: data.corteEspecial ?? false,
        plastificacao: data.plastificacao || null,
        dobraVinco: data.dobraVinco || null,
        espessura: data.espessura || null,
        suporteMaterial: data.suporteMaterial || null,
        // Campos adicionais do frontend (comentados temporariamente)
        pesoPapel: data.pesoPapel || null,
        mioloPapel: data.mioloPapel || null,
        capaPapel: data.capaPapel || null,
        encadernacao: data.encadernacao || null,
        laminacaoCapa: data.laminacaoCapa || null,
        precoPorM2: data.precoPorM2 || null,
        tipoTecido: data.tipoTecido || null,
        areaImpressao: data.areaImpressao || null,
        metodoImpressao2: data.metodoImpressao2 || null,
        materialObjeto: data.materialObjeto || null,
        dimensoes: data.dimensoes || null,
        materialSuporte: data.materialSuporte || null,
        espessura2: data.espessura2 || null,
        acabamento2: data.acabamento2 || null,
        atualizadoEm: new Date(),
      },
    })

    return NextResponse.json({ success: true, data: produtoAtualizado })
  } catch (error) {
    console.error("Erro ao atualizar produto:", error)
    return NextResponse.json({ success: false, message: "Erro ao atualizar produto" }, { status: 500 })
  }
}

// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// DELETE ‚Üí Inativa um produto (soft delete)
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
export async function DELETE(request: Request) {
  try {
    const { id } = await request.json()

    await prisma.produto.update({
      where: { id: Number(id) },
      data: { status: "INATIVO" },
    })

    return NextResponse.json({ success: true, message: "Produto inativado com sucesso" })
  } catch (error) {
    console.error("Erro ao excluir produto:", error)
    return NextResponse.json({ success: false, message: "Erro ao excluir produto" }, { status: 500 })
  }
}
